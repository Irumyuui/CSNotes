# Lec1: MapReduce

如果让一个计算任务能够尽量的快执行，那么第一件事想到就是**将任务进行并行**，或者是提升硬件的性能。对于单独的一个进程来说，可以使用多线程的方式来快速计算。

```rust
use itertools::Itertools;

fn calc(input: &[i32]) -> i32 {
    input.iter().sum()
}

fn main() {
    let input1 = (0..100).collect_vec();
    let input2 = (100..200).collect_vec();

    println!("Answer: {}", calc(&input1) + calc(&input2));

    let th1 = std::thread::spawn(move || calc(&input1));
    let th2 = std::thread::spawn(move || calc(&input2));

    let res = th1.join().unwrap() + th2.join().unwrap();
    println!("Result: {}", res);
}
```

对于单机系统来说，除了多线程以外，也可以采用多进程的架构方式，避免其中一个出现问题从而将所有计算结果崩溃（或捕获）。

但如果需要进行**扩展**，则单机很难进行扩展。此时可以借助网络，实现**分布式系统**，即将多台机子组成一个整体。

## 并行的问题

让一个过程并行涉及到的主要问题是：要怎么做？无论采取什么方式，总是要涉及到以下几点问题。

- 数据要如何传输？
- 如何执行计算？
- 如何保存结果？

### 多线程

对于计算的问题，则由用户提出如何计算。另一方面，需要对每个数据集进行合理的划分，期望能准确快速的计算。如果是数据传输，那么多线程内内存空间共享，无需考虑这件事情。但如果是保存结果，则需要涉及到**数据同步**的问题，不可避免的需要涉及到多线程同步的问题。

### 多进程

对于多进程来说，类似的问题和多线程类似，但有一个不同的点：数据传输。这依然是需要预先分配给每个进程其任务的量。

### 分布式系统

分布式系统则是有很多计算机，之间的交流通信通过网络来实现（特殊方式也可以），每个机子自己跑任务，然后汇总任务结果即可。

#### 扩展性

这样做的好处当然还是**方便扩展**，毕竟直接购买一台新机子比升级机子方便多了。从系统的角度上来说，如果不增加机子，那么对于系统的优化甚至重构的代价总是很高的。相比于升级机子或者找个大牛重构系统或者优化算法，加个机子就能提高整个系统的性能反而是最简单的做法了。

但这样做还有另外一个问题：这个系统真的可以一直加新机子做到扩展吗？答案是：你需要一个设计合理的架构才方便扩展。

让我们考虑一个 web 服务器：多台机子处理请求，数据存储在一个数据库中。面对越来越多的流量，当然加机子是最简单的事情。但随着机子越来越多，数据请求将越来越大，这些流量都将挤压到处理数据库的机子上，此时即使扩展机子也没啥用了。

#### 可用性

分布式系统带来的另外一个问题是：**系统可用吗**。

对于多线程来说，如果其中一个线程出现了问题，那么必须要其中做个处理，比如捕获异常，否则整个服务将不再可行。与之相反的一个架构则为多进程，启动服务将额外启动多个进程，互相监视进程的状态，一旦其中一个进程出现问题，则这些“守护进程”将自动重启对应的服务进程，**这种做法常见于一些多进程的 web 服务器，以及计算机病毒**。

上面的方式都是局限在一个机子上。对于分布式系统来说，其中的那么多台机子，如果其中一台出现了问题，比如维护人员正在维护，那么需要保证这个系统依然能够正常运转，就像本来就没有发生过错误一样。

当然另外一个问题是：如果错误了，能否恢复。像文件系统，如果你不小心没交电费，电脑突然关机了，那么你最后一次保存的数据基本还是在的。对于文件系统来说，保存的数据并不立刻写入对应的磁盘位置，而是采取另外一个方式，比如做个标记，一定要保证写入的数据是完整的，对应的方式就像维护一块缓冲区，写入第一份数据，然后重放该操作，直到所有数据都写入完成。

#### 一致性

多进程和多线程带来的挑战自然是：并发下数据的竞态问题。解决方法也很简单，上锁。会玩的高级一点的，也可以上无锁编程。

```rust
let mutex = Arc::new(Mutex::new(()));

if let Ok(_) = mutex.lock() {
    // do something...
} else {
    // lock failed...
};
```

对于分布式系统来说，问题则是多台机子之间的数据同步问题。回到之前的数据库问题，此时系统改为多台机子提供数据库服务，那么因为网络延迟的问题，可能从一台机子上获取的数据，对于另外一台机子来说是旧数据。

还有一个方面：速度。如果需要保持最强的一致性，那么这些机子每次都需要广播给其他机子，这会导致通信代价很昂贵，同时响应时间也会增加。如果你处理的数据**允许一部分的丢失**，也就是你获取到的数据只是某个最近的旧版本，但它确实是可以使用的，那么其实允许这一点错误，换来更好的性能反而是一件不错的事情。

## MapReduce

[MapReduce: Simplified Data Processing on Large Clusters](https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf)

MapReduce 是 Google 提出的一种分布式计算模型，其核心思想是：将大数据集分解为多个小数据集，然后并行计算，最后再合并结果。当然，这里的并行计算，指的是多台机子并行计算。

MapReduce 其中的 map 和 reduce 操作类似于函数式编程的思想：

```f#
let map f x = f x

let rec mapList f lst =
    match lst with
    | [] -> []
    | x :: xs -> f x :: mapList f xs

// left fold
let rec reduce f acc lst =
    match lst with
    | [] -> acc
    | x :: xs -> reduce f (f acc x) xs
```

`map` 处理输入数据，而 `reduce` 则合并结果。

`MapReduce` 的整体架构如下：

![Execution Overview](../../Assets/Image/Labs/MIT%206.824/MapReduce-Execution-Overview.png)

一个 `MapReduce` 集群实例，包括一个 `Master` 节点和多个 `Worker` 节点，`Master` 节点负责调度任务，也就是分配 `Job` 给 `Worker` 节点。`Map worker` 读入数据，然后执行用户自定义的 `map` 函数，输出 `(Key, Value)` ，然后将结果写在某个位置上，并通知 `Master`。`Master` 来通知 `Reduce worker` 读取数据，根据 `Key` 排个序并按 `Key` 分组，然后执行用户自定义的 `reduce` 函数，然后输出。等待 `Worker` 执行完毕后，`Master` 则通知执行完毕。

`Master` 会周期性的 ping 每个 `Worker`，如果 `Worker` 长时间没有响应，则认为其挂了，由该 `Worker` 上的 `map` 任务标记为初始状态，并重新分配给其他正常的 `Worker` 执行。

如果是 `Master` 出现问题，那么所有 `MapReduce` 则失败，由客户决定是否重新执行 `MapReduce` 。

### 瓶颈点

有趣的一个点是：`MapReduce` 输入数据需要让数据都准备好，不太能流式计算，所以这可能成为一个瓶颈点。

同时另外一个点，在整个集群内传输数据，需要耗费大量的流量，所以如果网络不够，则这样的模型其瓶颈卡在了网络上。

另外一个点，和多线程任务一致，如果存在一些 `Worker` 执行过慢，那么，任务总时间就被这些 `Worker` 拖累。
