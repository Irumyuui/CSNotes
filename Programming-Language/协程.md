## 前言

> 实际上这还是因为面试的事情，所以再再一次记录一下，以一个简单的方式，主要还是想按照状态机来介绍一下，按照状态机比较有意思。

要介绍协程之前，需要来一点背景知识。

### 回调函数

写过回调函数的朋友应该都知道，基于回调函数的模型代码可读性是有多差。

```c
void foo_async(void* context) {
    if (some...) {
        call_func(context);
    }
}

// call foo
foo_async(cx1);

// action
cx1.result ...
```

然而实际上，你可以使用更加优雅的方式。

```rust
async fn foo_async() -> i32 { 42 }
let result = foo_async().await;
```
### 中断与轮询

如果写过单片机的话，那么应该会遇到一个东西：一个设备需要执行某个操作，当它准备好的时候，应该使用中断还是轮询？

一个很自然的方式当然是使用中断钩子，只要一旦触发，那么直接使用中断即可。问题在于，如果使用中断，那么程序必须直接立刻处理当前的中断处理请求，没有办法稍后之类的。另外一件事，如果使用中断处理，那么像在 `linux` 中就很麻烦，因为涉及到内核态和用户态的切换，这个过程的开销和现在的 cpu 比，虽然小，但一些情况下还是不容忽视的，如果与轮询的函数调用相比的话。

另外，就是目前 cpu 的速度还是挺快的，轮询隔一段时间问一次，其实速度还不错。

## 引入协程

这里并不想讲任何的关于并发的模型，但确实协程的一个作用就是实现用户态的并发，不过我希望换一个角度来讲讲。

对于一个进程，其本身是一个不断输入命令序列和输出运行结果的状态机，其中包括一些线程，那么每个线程其实就是一个“函数”，我们启动一个线程，只是需要有一个额外的运行容器，去运行我们所需要的函数。

```rust
fn foo() { sleep(Duration::from_secs(10)); }
std::thread::spawn(foo);
```

因为启一个线程最后还是一步一步的调用，因此我们可以看作线程依然还是一个状态机，这个状态机的状态改变就是上下文的指令变动罢了。

那么思考一个问题：如果我目前需要一个等待结果的任务，可能是通讯等待对方发送回来，如果你是现实生活你该怎么做？自然是发送完看着其他东西然后等待发送回来的时候，自己去瞅一瞅。此时，人是一个状态机，只是从发送切换到干其他事情，然后回头看看事件结果了。

回过头看看代码，为什么我们就不能主动切换到另一个函数，让整个状态机是一个多个状态一起推进呢？启动线程本质上就是给整个状态机添加额外的输入，每个输入分别推进。

那么既然程序是一个巨大的状态机，总得有一个方式合适的描述这个状态机上的节点：

```rust
// 简略的实现
enum Task {
    State1(Context),
    State2(Context),
    ...    
};

impl Task {
    fn poll_next(self) -> Task {
        match self {
            Task::State1(context) => {
                let next_context = context.callback();
                Task::State2(next_context)
            }
            Task::State2(context) => {
                let next_context = context.callback();
                Task::State3(next_context)
            }
            ...
        }
    }
}
```

如果从这个角度上来看，无栈协程的实现角度其实就是跟上面的代码一样，最后所有的 `Task` 都交给一个调度器去 `poll` （不提 CPS），状态塞在这个结构体里面，或者用堆分配个位置，换句话来说依然是个状态机。

那么有栈协程呢，主动切换寄存器的方式，符合状态机吗？依然符合，状态去哪了？每个有栈协程自带一个栈，状态全塞里面了。

## 代替线程？

人话：代替不了，两个都不是同一个东西。

但是你可以实现一个基于多线程的协程运行时，这个场景下大家都是函数，只是你的函数在哪个线程上就不知道了。

有个语言就是按照这样的方式：

```csharp
var path = @"Cargo.toml";
using var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
using var reader = new StreamReader(fileStream, Encoding.UTF8);
var result = await reader.ReadToEndAsync();
```

自然，因为引入协程其实解决回调地狱的同时，引入很多抽象和函数调用，有的还需要分配额外空间和调度策略，所以实际上多多少少是会对性能有影响的，但一方面是不多，第二是整个代码的可维护性提升了。
