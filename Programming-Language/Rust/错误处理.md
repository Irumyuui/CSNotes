
相对于一些平常的语言来说，Rust 的错误处理需要编写者进行思考，并强制进行约束保证。

Rust 的错误设计为两种，根据是否可恢复区分。

可恢复的错误中，类型系统已经包含了错误可能发生的原因，一旦调用时强制上层要处理该错误，但也由于这样的原则，使得这套错误处理逻辑有时很头疼。

一个简单的做法是，上层重新定义一个新的错误类型，要么承接底层的错误并处理，要么向上直接返回错误。

```rust
struct DivZeroError;

fn foo(x: i32) -> Result<i32, DivZeroEror> {
    if x == 0 {
        Err(DivZeroError)
    } else {
        Ok(42 / x)
    }
}

let result = foo(0);
match result {
    Ok(res) => { ... }
    Err(e)  => { ... }
}
```

另一种则是不可恢复的错误，但其并非不可恢复，而是在多数情况下作为报错，将整体程序杀掉作为处理。

比如程序走到一个预料中不可能触及的位置时，此时应该为 `panic` ，对于 Rust 中则有一个宏，`unreachable` 。不过不管如何，这类错误一般对应的，是致命错误，也就是那些一定会导致程序停摆的情况，否则使用上一种即可。

```rust
fn foo(x: i32) -> i32 {
    match x {
        0 => panic!("div zero"),
        x => 42 / x,
    }
}
```