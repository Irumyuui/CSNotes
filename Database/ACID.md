# 事务的四大特性 ACID

ACID 是指事务（Transaction）的四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

## ACID 特性

- 原子性（Atomicity）: 就像原子变量一样，一次事务的表现就像一次单独的操作一样，中间不再分割，要么本次事务成功，要么失败。
- 一致性（Consistency）: 无论事务进行如何，数据都还是那个数据，没有发生破坏。
- 隔离性（Isolation）: 多个事务之间并发执行，但互不干扰
- 持久性（Durability）: 一旦事务提交，它对数据库的改变就永久保存下来，即使系统崩溃也不会丢失。

## ACID 实现

### 原子性

一种实现的方式是本地先写一个日志，然后等到事务提交时检查日志信息，如果事务提交成功，那么日志也就可以删除了，如果提交失败，那么通过这个日志文件来恢复数据库到事务开始时的状态。

这个过程很像某些文件系统的行为，当写入时可以在最后追加写入一个标志位，表示这个文件是成功写入的，如果中途断电了，文件系统可以通过这个标识来检查文件信息，至于怎么恢复数据，得看文件系统具体怎么保存之前的信息了，可能是写在一个地方但是还没正式写完，或者是干脆直接当作失败了。

### 隔离性

隔离性是这四个属性中，最难以实现的。

> 为什么是最难实现的，参考 `std::memory_order` ，如果对于多个并发事件发生时，操作的语句还存在可能重排的情况下，那么可能导致读写不一致的问题，这也是并发编程中最头疼的一个点。

隔离性定义的几个隔离级别为：

- 读未提交（Read Uncommitted）：允许脏读、不可重复读、幻读。
- 读提交（Read Committed）：保证事务只能读到已经提交的数据，可以避免脏读，但是可能出现不可重复读和幻读。
- 可重复读（Repeatable Read）：保证事务只能读到已经提交的数据，并且只能读到事务开始前已经提交的数据，可以避免不可重复读，但是可能出现幻读。
- 串行化（Serializable）：最高的隔离级别，事务之间完全串行执行，避免了脏读、不可重复读、幻读。

类型于内存序，读未提交则为 relaxed，读提交则为 acquire，可重复读则为 acquire-release，串行化则为 sequentially-consistent。越高级别的隔离新，安全性越高，但性能越低（不保证可能其他的实现能达到高性能，比如使用无锁数据结构）。

如果整个过程中，保证了是单线程（也就是全上下文都是串行的，而且不搞什么骚操作，比如一个东西没做完就开始做另外一个东西的异步过程），那么一定可以保证隔离性。

但我们现在讨论的是并发控制的实现。多个并发任务需要保证数据的一致性，实际上这也是多线程编程的一个共同问题。

#### 多版本并发控制（MVCC）

对于单独一个数据，我要多线程读或者写，那么是不是需要加锁？这就是两阶段锁，多个事务操作同一个对象的时候，需要等待另外一个事务释放锁。那么有没有降低锁粒度的方式？思考一下，如果数据不可变，那么是不是很好做了？那么这就是 MVCC 了。

MVCC 做到数据不改变的方式就是：可持久化数据。每一个数据都是其一个版本，对其的修改都是在之后添加新的数据，作为更新的版本而存在，那么读事务则直接读即可，写事务先读完然后再将数据写入，互不影响。

> 简单来说你现在每一次操作都是一次新的版本，老的版本随便读，改不了，这也带了点函数式编程的味道。

基于 MVCC 实现的事务隔离方式，有一种就叫做**快照隔离**（Snapshot Isolation，简称 SI）。但这也其实带来了一个问题：写偏斜问题。

> 写偏斜问题：假如我现在有两个变量 a b ，现在有两个线程 t1 t2 ，有个约束条件 `a + b >= 0` ，基于上面的快照思想，t1 t2 各自会读取一份 a b ，但是 t1 只修改 a ，t2 也只修改 b ，那么这时候 t1 t2 都会提交，但是这时候 a b 可能就不满足约束条件了。

如何解决呢？还是**加锁**。也就是**串行化隔离级别**（Serializable Snapshot Isolation，简称 SSI）。SI 只检测写写冲突，所以导致读的时候也发生了冲突但被意外忽略了。而 SSI 则会检测读过的数据，对读过的数据进行追踪，提交的时候进行检测。

<!-- TODO：SSI 具体实现 -->
