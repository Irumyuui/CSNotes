# 内存管理

## 1. 基本信息

伙伴算法

## 2. 记录内存空间使用情况

这里使用了一个 `struct TaskInfo` 的结构体进行存储进程信息。

```c
// 进程信息记录
struct TaskInfo {
    i32 state;  // 进程状态 1 := 待分配 2 := 分配完成 0 := 进程结束 -1 := 分配失败
    u64 pid;  // 进程标识符
    u64 needSize;  // 进程所需要的内存大小
    u64 realSize;  // 进程实际被分配的内存大小
    void *addr;  // 分配的地址
};

// 一些支持的函数
void TaskInfoInit(struct TaskInfo *this, u64 pid, u64 needSize) {
    this->pid = pid;
    this->needSize = needSize;
    
    this->state = 0;
    this->realSize = -1;
    this->addr = NULL;
}

void __TaskInit(struct TaskInfo *this) {
    u64 pid, needSize;
    scanf("%lu %lu", &pid, &needSize);
    TaskInfoInit(this, pid, needSize);
}
void __TaskFormatPrint(struct TaskInfo *this) {
    if (this->state != 2) {
        printf("PID: %lu; Need size: %lu; State: %d. \n", this->pid, this->needSize, this->state);
    } else {
        printf("PID: %lu; Need size: %lu; State: %d; Addr: %lu; Real size: %lu. \n", 
                this->pid, this->needSize, this->state, (u64)this->addr, this->realSize);
    }
}
```

## 3. 记录空闲分区

在实现的算法中使用了一颗二叉树管理内存空间，因此看二叉树的使用情况可以知道哪一部分的内存空间被使用。

树上的节点为 `struct FreeBlack` ，若该节点的 `size` 正好是其原本的大小，那么这个节点的内存空间就是空闲的，否则维护子树节点的 `size` 最大值，供后续查找空闲块使用。

当对应的内存块被分配时，树上的内存块将被标记为 $0$ ，供树的信息更新。

二叉树并没有用链表建立，而是用数组存储。由于内存块为 $2^x$ 的形式，因此可以使用数组存储一颗满二叉树。

```c
typedef int32_t i32;
typedef int64_t i64;

typedef uint32_t u32;
typedef uint64_t u64;

struct FreeBlock {
    u64 size;  // 如果该位置可用，那么 size == levelSize ，否则 size = max(lc.size, rc.size) 或 0
    u64 *addr; // 数组起点 
};

struct MemAlloc {
    u64 totSize;  // 内存池总大小
    u64 *startAddr;  // 内存池起始地址
    struct FreeBlock *freeList;  // 满二叉树管理内存位置
};

// 计算 size 目前的等级
u64 GetSizeLevel(u64 size) {
    u64 level = 0;
    while (size > 0) {
        level ++;
        size >>= 1;
    }
    return level;
}

// 计算左节点位置
u64 __GetLeftChildIndex(u64 parentIndex) {
    return parentIndex * 2 + 1;
}
// 计算右节点位置
u64 __GetRigntChildIndex(u64 parentIndex) {
    return parentIndex * 2 + 2;
}
// 计算父亲节点位置
u64 __GetParentIndex(u64 childIndex) {
    return (childIndex + 1) / 2 - 1;
}
```

因为管理方式在一颗树上，因此直接遍历就可以输出内存块的情况。

```c
// 打印树上的信息
void DfsPrint(struct FreeBlock *freeList, u64 index, u64 level, int tabShift) {
    struct FreeBlock *now = &freeList[index];
    for (int i = 0; i < tabShift; i ++) {
        printf(" ");
    }
    printf("- %lu => Index: %lu. Node size: %lu. Addr: %lu. \n", level, index, now->size, (u64)now->addr);
    if (level == 1 || now->size == 0) {
        return;
    }
    DfsPrint(freeList, __GetLeftChildIndex(index), level - 1, tabShift + 2);
    DfsPrint(freeList, __GetRigntChildIndex(index), level - 1, tabShift + 2);
}
```

对 `struct MemAlloc` 的初始化和析构，对二叉树上的节点记录其目前管辖的内存大小及其管辖的内存起点。由于这个二叉树一定是一颗满二叉树，因此如果要成功构造的话，就需要申请内存符合 $2^x$ 的大小，才可以确保以静态数组的方式存储的二叉树的形态符合要求，否则构造失败。同时， `startAddr` 才是内存的真正起点，二叉树只是用来管理内存空间的分配和回收。

```c
// 判断是否是 2^X
i32 __IsPowerOf2(u64 size) {
    return !(size & (size - 1));
}

// 调整 size 为 最小的 2^X > size
u64 __FixSize64(u64 size) {
    size |= size >> 1;
    size |= size >> 2;
    size |= size >> 4;
    size |= size >> 8;
    size |= size >> 16;
    size |= size >> 32;
    return size + 1;
}

// 初始化二叉树所有信息
void __FreeBlockListAddrInit(struct FreeBlock *freeList, u64 index, u64 *startAddr, u64 size) {
    // 初始化节点信息
    freeList[index].size = size;
    freeList[index].addr = startAddr;

    // 最小分配内存大小节点为 1
    if (size == 1) {
        return;
    }

    // 分配左右节点
    __FreeBlockListAddrInit(freeList, __GetLeftChildIndex(index), startAddr, size / 2);
    __FreeBlockListAddrInit(freeList, __GetRigntChildIndex(index), &startAddr[size / 2], size / 2);
}

// 内存适配器 构造函数
i32 MemAllocInit(struct MemAlloc *this, u64 size) {
    // 判断当前对象是否合法
    // 判断当前分配内存是否合法
    if (this == NULL || size == 0 || !__IsPowerOf2(size)) {
        return -1;
    }

    // 申请连续空间
    // [0, size - 1] 为 内存池
    // 从 size 开始的 [0, 2 * size - 1] 为二叉树
    u64 *addr = (u64*)malloc(
            sizeof(u64) * size 
            + (size * 2 - 1) * sizeof(struct FreeBlock)
        );

    // 申请内存失败
    if (addr == NULL) {
        return -1;
    }
    
    // 初始化 allocator
    this->totSize = size;
    // 分配地址
    this->startAddr = addr;
    this->freeList = (struct FreeBlock*)(&(addr[size]));

    // 初始化 freeList
    __FreeBlockListAddrInit(this->freeList, 0, addr, size);
    
    return 0;
}

// 内存适配器 析构函数
void MemAllocDel(struct MemAlloc *this) {
    free(this->startAddr);
    this->startAddr = NULL;
}
```

## 4. 内存分配算法

```c
u64 __FindFreeMemAddr(struct FreeBlock *freeList, u64 index, u64 needSize, u64 levelSize);
void __RecalcFreeListSize(struct FreeBlock *freeList, u64 index);
void* __MemAlloc(struct MemAlloc *this, u64 size);
void* MemAlloc(struct MemAlloc *this, u64 size);
```

以上是主要使用的函数声明。

使用内存分配算法：使用二叉树管理内存块的伙伴系统。

> 使用二叉树是因为一开始希望找到一种方式找到最大的空闲内存块，合并的时候在树上左右两个孩子节点就可以直接合并成父亲节点，同时如果内存块是 $2^x$ 的形式的话合并也比较方便，然后实现就变成了用一颗二叉树去管理内存块的分配和合并的伙伴系统了。

`MemAllo` 为对外正式分配内存的函数，在函数中会检查所要分配的内存是否已经超过内存池的大小，之后将分配一个内存块，这个内存块携带有一个 `size` 信息，用于记录这次分配的内存块的全部大小（包括了 `size` ）。此外，由于我们的内存块大小都是 $2$ 的次幂，因此我们还需要对块的大小进行预处理一下，让申请的内存块符合我们管理内存块的模型。最后它将返回 `void*` 的指针，供外部使用。

之后调用的三个函数都是在保证了传入参数一定是合法的情况下的动作。

`__MemAlloc` 将处理对内存块的正式分配，首先它将调用 `__FindFreeMemAddr` ，找到树中符合条件内存块，并将其标记为已分配内存，之后调用 `__RecalcFreeListSize`， 将重新调整二叉树中的信息，以利于维护，最后返回分配的内存块首地址。

`__FindFreeMemAddr` 在树中查找一个符合条件的内存块节点。如果目前这个节点的内存是满的（也就是在这个层级上它没被分配），那么我们将其一分为二，将它所管理的内存给予其左右两个孩子节点管理，否则找到其中一个符合条件的内存块即可。最后它将返回所找到的孩子节点位于数组的下标。

`__RecalcFreeListSize` 将处理分配内存后树信息的调整工作。由于已经分配内存，因此其向上维护的信息一定是没有完全的，所以它所做的工作就是从这个节点开始，维护树上内存块最大大小信息，而不需要考虑伙伴内存块的合并问题。

```c
// 调整 size 为 最小的 2^X > size
u64 __FixSize64(u64 size) {
    size |= size >> 1;
    size |= size >> 2;
    size |= size >> 4;
    size |= size >> 8;
    size |= size >> 16;
    size |= size >> 32;
    return size + 1;
}

// 查找二叉树数组索引下的下标位置
// 需要保证一定有剩余的可分配内存
u64 __FindFreeMemAddr(struct FreeBlock *freeList, u64 index, u64 needSize, u64 levelSize) {
    if (needSize == levelSize) {
        return index;
    }
    
    // 计算孩子节点
    u64 lc = __GetLeftChildIndex(index), rc = __GetRigntChildIndex(index);
    // 如果两边的剩余内存都符合
    if (freeList[lc].size >= needSize && freeList[rc].size >= needSize) {
        // 找一个剩余空间大的
        if (freeList[lc].size >= freeList[rc].size) {
            return __FindFreeMemAddr(freeList, lc, needSize, levelSize >> 1);
        } else {
            return __FindFreeMemAddr(freeList, rc, needSize, levelSize >> 1);
        }
    // 否则找其中符合的
    } else if (freeList[lc].size >= needSize) {
        return __FindFreeMemAddr(freeList, lc, needSize, levelSize >> 1);
    } else {
        return __FindFreeMemAddr(freeList, rc, needSize, levelSize >> 1);
    }
}

// 重新向上计算大小信息
// 不合并内存
void __RecalcFreeListSize(struct FreeBlock *freeList, u64 index) {
    DEBUG("Index: %lu", index);

    u64 parentIndex = __GetParentIndex(index);
    u64 lc = __GetLeftChildIndex(parentIndex), rc = __GetRigntChildIndex(parentIndex);

    freeList[parentIndex].size 
        = freeList[lc].size >= freeList[rc].size ? freeList[lc].size : freeList[rc].size;
    
    if (parentIndex > 0) {
        __RecalcFreeListSize(freeList, parentIndex);
    }
}

// 分配大小为 size 的内存
// 要求 size 符合条件
void* __MemAlloc(struct MemAlloc *this, u64 size) {
    // 找到存在剩余内存的下标
    u64 index = __FindFreeMemAddr(this->freeList, 0, size, this->totSize);
    
    // 将这个节点的内存大小标志为 0
    // 表示该位置已经分配内存
    this->freeList[index].size = 0;

    // 分配后重新调整树的信息
    if (index > 0)
        __RecalcFreeListSize(this->freeList, index);

    return (void*)this->freeList[index].addr;
}

// 正式分配内存
void* MemAlloc(struct MemAlloc *this, u64 size) {
    // 调整符合的内存
    // 需要额外空间存储分配的大小
    size = __FixSize64(size + 1);
    
    // 判断请求分配的内存空间是否超过目前可以分配的最大内存块
    if (this->freeList[0].size < size) {
        return NULL;
    }

    // 调用分配
    u64 *addr = (u64*)__MemAlloc(this, size);

    // 初始位置存储分配内存总大小
    // 方便释放内存
    *addr = size;
    
    return (void*)(&addr[1]);
}
```

## 4. 内存释放算法

```c
u64 __FindAllocAddrIndex(struct FreeBlock *freeList, u64 *addr, u64 index, u64 tagetSize, u64 levelSize);
void __RecalcFreeListSizeWithMerge(struct FreeBlock *freeList, u64 index, u64 levelSize);
void MemDealloc(struct MemAlloc *this, u64 *allocAddr);
```

以上是一些主要使用到的函数声明。

释放内存时，需要要求传入之前所申请得到的内存首地址，这样才可以正常释放内存。

> 合并伙伴内存块。

`MemDealloc` 是对外的释放内存的函数，它将先计算所要释放的内存块的大小，从而确定这个内存块在申请的时候所属于的节点是哪一个，同时也计算这个内存块最开始的地址（因为首地址的一个 `u64` 大小存储了内存块的大小）。之后，交给 `__FindAllocAddrIndex` 计算这个节点的确切位置，最后对这个节点做标记，表示这个节点的内存已被归还了，并由 `__RecalcFreeListSizeWithMerge` 进行收尾的树上信息处理。

`__FindAllocAddrIndex` 用于查找树上节点位置的索引下标。具体来说，这颗满二叉树的每一层的节点都代表着具体的内存大小，从根的大小一直对半分裂到所有叶子节点，我们只需要考虑的是：在我们达到目标层的过程中，引导至目的节点。利用树的性质，我们可以知道这样管理内存时，其中序遍历的地址是连续的（换句话说，从左儿子到右儿子的区间内存范围是连续的，因为这两个节点的内存空间合并后就是它们父亲节点的空闲内存空间），因此，我们只需要根据原本被分配的地址和每个节点所代表的地址进行比较，就可以找到原先被分配的节点位置。

`__RecalcFreeListSizeWithMerge` 用于释放内存的收尾工作。具体来讲，在归还目标节点后，需要重新更新树上信息。由于现在已经归还了内存，那么就需要考虑：父亲节点管理的空闲内存是否也已经空闲，那么在向上更新的时候我们就需要考虑左右儿子节点的空闲内存是否都已经达到这一层的内存大小，如果达到，那么意味着这两个空闲内存块可以合并为父亲节点的空闲内存块，否则我们依然考虑将更新树上最大内存块信息。

```c
// 查找到合适的分配内存位置
u64 __FindAllocAddrIndex(struct FreeBlock *freeList, u64 *addr, u64 index, u64 tagetSize, u64 levelSize) {
    DEBUG("Index: %lu; TargetSize: %lu; LevelSize: %lu", index, tagetSize, levelSize);
    // 如果这个节点是目标节点
    if (tagetSize == levelSize) {
        return index;
    }

    // 向下继续寻找
    u64 lc = __GetLeftChildIndex(index), rc = __GetRigntChildIndex(index);
    DEBUG("LC: size %lu, addr %lu; RC: size %lu, addr %lu", freeList[lc].size, freeList[lc].addr, freeList[rc].size, freeList[rc].addr);
    // 通过指针偏移位置来确定位置
    if (freeList[rc].addr > addr) {
        return __FindAllocAddrIndex(freeList, addr, lc, tagetSize, levelSize >> 1);
    } else {
        return __FindAllocAddrIndex(freeList, addr, rc, tagetSize, levelSize >> 1);
    }
}

// 向上更新树的信息
// 带有内存块合并
void __RecalcFreeListSizeWithMerge(struct FreeBlock *freeList, u64 index, u64 levelSize) {
    DEBUG("Index: %lu; LevelSize: %lu", index, levelSize);
    u64 parentIndex = __GetParentIndex(index);
    u64 lc = __GetLeftChildIndex(parentIndex), rc = __GetRigntChildIndex(parentIndex);

    // 如果孩子的内存都是空的 那么就可以合并
    if (freeList[lc].size == levelSize && freeList[rc].size == levelSize) {
        freeList[parentIndex].size = levelSize << 1;
    } else {
        // 否则更新最大值
        freeList[parentIndex].size 
            = freeList[lc].size >= freeList[rc].size 
                ? freeList[lc].size : freeList[rc].size;
    }

    // 如果还没到根节点
    if (parentIndex > 0) {
        __RecalcFreeListSizeWithMerge(freeList, parentIndex, levelSize << 1);
    }
}

// 归还内存
// 要求传入的地址与分配时的地址是符合的
void MemDealloc(struct MemAlloc *this, u64 *allocAddr) {
    // 计算分配时内存地址位置
    u64 *addr = &(allocAddr[-1]);
    // 获取分配时内存块大小
    u64 size = *addr;

    // 查找被分配的节点位置
    u64 index = __FindAllocAddrIndex(this->freeList, addr, 0, size, this->totSize);
    DEBUG("Index: %lu", index);
    assert(this->freeList[index].size == 0);

    // 归还内存 并重新调整树上信息
    this->freeList[index].size = size;
    if (index > 0)
        __RecalcFreeListSizeWithMerge(this->freeList, index, size);
}
```

## 6. 测试

### 6.1 测试使用代码

这边写了个比较简单的 `makefile` 构建。

```makefile
all: mem.out test.out

mem.out: mem.c
	gcc -pipe -O0 -Wall -g -fsanitize=address -fsanitize=undefined mem.c -o mem.out

test.out: test.cpp
	g++ -pipe -O3 test.cpp -o test.out
```

执行命令 `echo 10 | ./test.out | ./mem.out` ，随机十组测试数据会输出至文件中，位于 `out` 文件夹下。

> 向 `test` 输入测试组数。
>
> `-fsanitize=address -fsanitize=undefined` 用于调试。

测试的主要代码如下。首先将按站预先大小创建 `struct MemAlloc` ，并从外部读入四个模拟进程的信息，并根据每个进程的状态进行分配和回收内存。

```c
void TestTask() {
    struct MemAlloc memAlloc;
    if (MemAllocInit(&memAlloc, TEST_ALLOC_SIZE) == -1) {
        printf("Alloc init failure. \n");
        return;
    }

#define PRINT_MEM_ALLOC_LIST puts("MemAlloc Tree: "); DfsPrint(memAlloc.freeList, 0, GetSizeLevel(memAlloc.totSize), 0); puts("")

    PRINT_MEM_ALLOC_LIST;

    struct TaskInfo task[TEST_TASK];

    printf("Task Init: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        __TaskInit(&task[i]);
        __TaskFormatPrint(&task[i]);
    }
    puts("");
    
    PRINT_MEM_ALLOC_LIST;

    printf("Task Memory Alloc: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        u64* addr = (u64*)MemAlloc(&memAlloc, task[i].needSize);
        DEBUG("addr: %lu", (u64)(&(addr[-1])));
        if (addr == NULL) {
            task[i].state = -1;
        } else {
            task[i].addr = addr;
            task[i].realSize = addr[-1];
            task[i].state = 2;
        }
        __TaskFormatPrint(&task[i]);
    }
    puts("");

    PRINT_MEM_ALLOC_LIST;

    printf("Task Memory Dealloc: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        DEBUG("Tast: %d", i);
        if (task[i].state == 2) {
            MemDealloc(&memAlloc, task[i].addr);
            task[i].state = 0;
        }
        __TaskFormatPrint(&task[i]);
    }
    puts("");

    PRINT_MEM_ALLOC_LIST;

    MemAllocDel(&memAlloc);

#undef PRINT_MEM_ALLOC_LIST
}

// int main() {
//     TestTask();
// }

int main() {
    int n;
    scanf("%d", &n);
    
    for (int i = 0; i < n; i ++) {
        char fd[100];
        sprintf(fd, "out/%d.txt", i);
        freopen(fd, "w+", stdout);
        TestTask();
    }
}
```

### 6.2 测试产生数据

测试产生数据使用 `std::mt19937` 产生，可以近似看作为随机。

```cpp
std::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());
```

在测试程序产生代码中，需要先读入测试总组数，之后随机生成 $4$ 个进程所需要的内存。

```cpp
int main() {
    constexpr int size_limit = 1 << 5;

    std::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());

    int tot_test;
    std::cin >> tot_test;

    std::cout << tot_test << '\n';
    for (int i = 0; i < tot_test; i ++) {
        for (int i = 0; i < 4; i ++) {
            auto pid = i;
            auto need_size = rnd() % size_limit + 1; // 限制范围在 [1, size_limit]
            std::cout << pid << ' ' << need_size << '\n';
        }
    }
}
```

### 6.3 解释结果

模拟进程的初始情况如下。

```text
PID: 0; Need size: 6; State: 0. 
PID: 1; Need size: 20; State: 0. 
PID: 2; Need size: 25; State: 0. 
PID: 3; Need size: 4; State: 0. 
```

在内存分配后，各个进程的分配和树上内存分配情况如下（因为输出过多，所以放在这边解释）。

对进程 0 来说，因为原本还有足够的空间，因此分配到的是 7 号节点所管理的内存块。

![1](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/1.png)

之后更新上去节点，树的部分结构就像这样。

![2](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/2.png)

因此，我们可以得到进程 1 的分配结果。

![](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/3.png)

那么为什么进程 2 不行呢？注意到进程 2 的申请内存大小为 25 ，按照我们的调整策略，它应该会得到一个完整的 32 大小的内存块，但是从上图看没有，因此它没法被分配。

进程 3 呢？当然可以，还有很多空间。（因为这里实现的是按大内存块分，也可以按小内存块分）。

![](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/4.png)

对于进程 1 内存的回收，如下图所显示。

![](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/5.png)

寻找到路径后，将恢复内存块信息，并做伙伴内存块合并的操作。

![](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/6.png)

对于进程 1 和进程 3 ，也是如此。

![](/home/cirno/桌面/学科/操作系统/exp6-4/README.assets/7.png)

```text
MemAlloc Tree: 
- 7 => Index: 0. Node size: 64. Addr: 107614700568704. 
  - 6 => Index: 1. Node size: 32. Addr: 107614700568704. 
    - 5 => Index: 3. Node size: 16. Addr: 107614700568704. 
      - 4 => Index: 7. Node size: 8. Addr: 107614700568704. 
        - 3 => Index: 15. Node size: 4. Addr: 107614700568704. 
          - 2 => Index: 31. Node size: 2. Addr: 107614700568704. 
            - 1 => Index: 63. Node size: 1. Addr: 107614700568704. 
            - 1 => Index: 64. Node size: 1. Addr: 107614700568712. 
          - 2 => Index: 32. Node size: 2. Addr: 107614700568720. 
            - 1 => Index: 65. Node size: 1. Addr: 107614700568720. 
            - 1 => Index: 66. Node size: 1. Addr: 107614700568728. 
        - 3 => Index: 16. Node size: 4. Addr: 107614700568736. 
          - 2 => Index: 33. Node size: 2. Addr: 107614700568736. 
            - 1 => Index: 67. Node size: 1. Addr: 107614700568736. 
            - 1 => Index: 68. Node size: 1. Addr: 107614700568744. 
          - 2 => Index: 34. Node size: 2. Addr: 107614700568752. 
            - 1 => Index: 69. Node size: 1. Addr: 107614700568752. 
            - 1 => Index: 70. Node size: 1. Addr: 107614700568760. 
      - 4 => Index: 8. Node size: 8. Addr: 107614700568768. 
        - 3 => Index: 17. Node size: 4. Addr: 107614700568768. 
          - 2 => Index: 35. Node size: 2. Addr: 107614700568768. 
            - 1 => Index: 71. Node size: 1. Addr: 107614700568768. 
            - 1 => Index: 72. Node size: 1. Addr: 107614700568776. 
          - 2 => Index: 36. Node size: 2. Addr: 107614700568784. 
            - 1 => Index: 73. Node size: 1. Addr: 107614700568784. 
            - 1 => Index: 74. Node size: 1. Addr: 107614700568792. 
        - 3 => Index: 18. Node size: 4. Addr: 107614700568800. 
          - 2 => Index: 37. Node size: 2. Addr: 107614700568800. 
            - 1 => Index: 75. Node size: 1. Addr: 107614700568800. 
            - 1 => Index: 76. Node size: 1. Addr: 107614700568808. 
          - 2 => Index: 38. Node size: 2. Addr: 107614700568816. 
            - 1 => Index: 77. Node size: 1. Addr: 107614700568816. 
            - 1 => Index: 78. Node size: 1. Addr: 107614700568824. 
    - 5 => Index: 4. Node size: 16. Addr: 107614700568832. 
      - 4 => Index: 9. Node size: 8. Addr: 107614700568832. 
        - 3 => Index: 19. Node size: 4. Addr: 107614700568832. 
          - 2 => Index: 39. Node size: 2. Addr: 107614700568832. 
            - 1 => Index: 79. Node size: 1. Addr: 107614700568832. 
            - 1 => Index: 80. Node size: 1. Addr: 107614700568840. 
          - 2 => Index: 40. Node size: 2. Addr: 107614700568848. 
            - 1 => Index: 81. Node size: 1. Addr: 107614700568848. 
            - 1 => Index: 82. Node size: 1. Addr: 107614700568856. 
        - 3 => Index: 20. Node size: 4. Addr: 107614700568864. 
          - 2 => Index: 41. Node size: 2. Addr: 107614700568864. 
            - 1 => Index: 83. Node size: 1. Addr: 107614700568864. 
            - 1 => Index: 84. Node size: 1. Addr: 107614700568872. 
          - 2 => Index: 42. Node size: 2. Addr: 107614700568880. 
            - 1 => Index: 85. Node size: 1. Addr: 107614700568880. 
            - 1 => Index: 86. Node size: 1. Addr: 107614700568888. 
      - 4 => Index: 10. Node size: 8. Addr: 107614700568896. 
        - 3 => Index: 21. Node size: 4. Addr: 107614700568896. 
          - 2 => Index: 43. Node size: 2. Addr: 107614700568896. 
            - 1 => Index: 87. Node size: 1. Addr: 107614700568896. 
            - 1 => Index: 88. Node size: 1. Addr: 107614700568904. 
          - 2 => Index: 44. Node size: 2. Addr: 107614700568912. 
            - 1 => Index: 89. Node size: 1. Addr: 107614700568912. 
            - 1 => Index: 90. Node size: 1. Addr: 107614700568920. 
        - 3 => Index: 22. Node size: 4. Addr: 107614700568928. 
          - 2 => Index: 45. Node size: 2. Addr: 107614700568928. 
            - 1 => Index: 91. Node size: 1. Addr: 107614700568928. 
            - 1 => Index: 92. Node size: 1. Addr: 107614700568936. 
          - 2 => Index: 46. Node size: 2. Addr: 107614700568944. 
            - 1 => Index: 93. Node size: 1. Addr: 107614700568944. 
            - 1 => Index: 94. Node size: 1. Addr: 107614700568952. 
  - 6 => Index: 2. Node size: 32. Addr: 107614700568960. 
    - 5 => Index: 5. Node size: 16. Addr: 107614700568960. 
      - 4 => Index: 11. Node size: 8. Addr: 107614700568960. 
        - 3 => Index: 23. Node size: 4. Addr: 107614700568960. 
          - 2 => Index: 47. Node size: 2. Addr: 107614700568960. 
            - 1 => Index: 95. Node size: 1. Addr: 107614700568960. 
            - 1 => Index: 96. Node size: 1. Addr: 107614700568968. 
          - 2 => Index: 48. Node size: 2. Addr: 107614700568976. 
            - 1 => Index: 97. Node size: 1. Addr: 107614700568976. 
            - 1 => Index: 98. Node size: 1. Addr: 107614700568984. 
        - 3 => Index: 24. Node size: 4. Addr: 107614700568992. 
          - 2 => Index: 49. Node size: 2. Addr: 107614700568992. 
            - 1 => Index: 99. Node size: 1. Addr: 107614700568992. 
            - 1 => Index: 100. Node size: 1. Addr: 107614700569000. 
          - 2 => Index: 50. Node size: 2. Addr: 107614700569008. 
            - 1 => Index: 101. Node size: 1. Addr: 107614700569008. 
            - 1 => Index: 102. Node size: 1. Addr: 107614700569016. 
      - 4 => Index: 12. Node size: 8. Addr: 107614700569024. 
        - 3 => Index: 25. Node size: 4. Addr: 107614700569024. 
          - 2 => Index: 51. Node size: 2. Addr: 107614700569024. 
            - 1 => Index: 103. Node size: 1. Addr: 107614700569024. 
            - 1 => Index: 104. Node size: 1. Addr: 107614700569032. 
          - 2 => Index: 52. Node size: 2. Addr: 107614700569040. 
            - 1 => Index: 105. Node size: 1. Addr: 107614700569040. 
            - 1 => Index: 106. Node size: 1. Addr: 107614700569048. 
        - 3 => Index: 26. Node size: 4. Addr: 107614700569056. 
          - 2 => Index: 53. Node size: 2. Addr: 107614700569056. 
            - 1 => Index: 107. Node size: 1. Addr: 107614700569056. 
            - 1 => Index: 108. Node size: 1. Addr: 107614700569064. 
          - 2 => Index: 54. Node size: 2. Addr: 107614700569072. 
            - 1 => Index: 109. Node size: 1. Addr: 107614700569072. 
            - 1 => Index: 110. Node size: 1. Addr: 107614700569080. 
    - 5 => Index: 6. Node size: 16. Addr: 107614700569088. 
      - 4 => Index: 13. Node size: 8. Addr: 107614700569088. 
        - 3 => Index: 27. Node size: 4. Addr: 107614700569088. 
          - 2 => Index: 55. Node size: 2. Addr: 107614700569088. 
            - 1 => Index: 111. Node size: 1. Addr: 107614700569088. 
            - 1 => Index: 112. Node size: 1. Addr: 107614700569096. 
          - 2 => Index: 56. Node size: 2. Addr: 107614700569104. 
            - 1 => Index: 113. Node size: 1. Addr: 107614700569104. 
            - 1 => Index: 114. Node size: 1. Addr: 107614700569112. 
        - 3 => Index: 28. Node size: 4. Addr: 107614700569120. 
          - 2 => Index: 57. Node size: 2. Addr: 107614700569120. 
            - 1 => Index: 115. Node size: 1. Addr: 107614700569120. 
            - 1 => Index: 116. Node size: 1. Addr: 107614700569128. 
          - 2 => Index: 58. Node size: 2. Addr: 107614700569136. 
            - 1 => Index: 117. Node size: 1. Addr: 107614700569136. 
            - 1 => Index: 118. Node size: 1. Addr: 107614700569144. 
      - 4 => Index: 14. Node size: 8. Addr: 107614700569152. 
        - 3 => Index: 29. Node size: 4. Addr: 107614700569152. 
          - 2 => Index: 59. Node size: 2. Addr: 107614700569152. 
            - 1 => Index: 119. Node size: 1. Addr: 107614700569152. 
            - 1 => Index: 120. Node size: 1. Addr: 107614700569160. 
          - 2 => Index: 60. Node size: 2. Addr: 107614700569168. 
            - 1 => Index: 121. Node size: 1. Addr: 107614700569168. 
            - 1 => Index: 122. Node size: 1. Addr: 107614700569176. 
        - 3 => Index: 30. Node size: 4. Addr: 107614700569184. 
          - 2 => Index: 61. Node size: 2. Addr: 107614700569184. 
            - 1 => Index: 123. Node size: 1. Addr: 107614700569184. 
            - 1 => Index: 124. Node size: 1. Addr: 107614700569192. 
          - 2 => Index: 62. Node size: 2. Addr: 107614700569200. 
            - 1 => Index: 125. Node size: 1. Addr: 107614700569200. 
            - 1 => Index: 126. Node size: 1. Addr: 107614700569208. 

Task Init: 
PID: 0; Need size: 6; State: 0. 
PID: 1; Need size: 20; State: 0. 
PID: 2; Need size: 25; State: 0. 
PID: 3; Need size: 4; State: 0. 

MemAlloc Tree: 
- 7 => Index: 0. Node size: 64. Addr: 107614700568704. 
  - 6 => Index: 1. Node size: 32. Addr: 107614700568704. 
    - 5 => Index: 3. Node size: 16. Addr: 107614700568704. 
      - 4 => Index: 7. Node size: 8. Addr: 107614700568704. 
        - 3 => Index: 15. Node size: 4. Addr: 107614700568704. 
          - 2 => Index: 31. Node size: 2. Addr: 107614700568704. 
            - 1 => Index: 63. Node size: 1. Addr: 107614700568704. 
            - 1 => Index: 64. Node size: 1. Addr: 107614700568712. 
          - 2 => Index: 32. Node size: 2. Addr: 107614700568720. 
            - 1 => Index: 65. Node size: 1. Addr: 107614700568720. 
            - 1 => Index: 66. Node size: 1. Addr: 107614700568728. 
        - 3 => Index: 16. Node size: 4. Addr: 107614700568736. 
          - 2 => Index: 33. Node size: 2. Addr: 107614700568736. 
            - 1 => Index: 67. Node size: 1. Addr: 107614700568736. 
            - 1 => Index: 68. Node size: 1. Addr: 107614700568744. 
          - 2 => Index: 34. Node size: 2. Addr: 107614700568752. 
            - 1 => Index: 69. Node size: 1. Addr: 107614700568752. 
            - 1 => Index: 70. Node size: 1. Addr: 107614700568760. 
      - 4 => Index: 8. Node size: 8. Addr: 107614700568768. 
        - 3 => Index: 17. Node size: 4. Addr: 107614700568768. 
          - 2 => Index: 35. Node size: 2. Addr: 107614700568768. 
            - 1 => Index: 71. Node size: 1. Addr: 107614700568768. 
            - 1 => Index: 72. Node size: 1. Addr: 107614700568776. 
          - 2 => Index: 36. Node size: 2. Addr: 107614700568784. 
            - 1 => Index: 73. Node size: 1. Addr: 107614700568784. 
            - 1 => Index: 74. Node size: 1. Addr: 107614700568792. 
        - 3 => Index: 18. Node size: 4. Addr: 107614700568800. 
          - 2 => Index: 37. Node size: 2. Addr: 107614700568800. 
            - 1 => Index: 75. Node size: 1. Addr: 107614700568800. 
            - 1 => Index: 76. Node size: 1. Addr: 107614700568808. 
          - 2 => Index: 38. Node size: 2. Addr: 107614700568816. 
            - 1 => Index: 77. Node size: 1. Addr: 107614700568816. 
            - 1 => Index: 78. Node size: 1. Addr: 107614700568824. 
    - 5 => Index: 4. Node size: 16. Addr: 107614700568832. 
      - 4 => Index: 9. Node size: 8. Addr: 107614700568832. 
        - 3 => Index: 19. Node size: 4. Addr: 107614700568832. 
          - 2 => Index: 39. Node size: 2. Addr: 107614700568832. 
            - 1 => Index: 79. Node size: 1. Addr: 107614700568832. 
            - 1 => Index: 80. Node size: 1. Addr: 107614700568840. 
          - 2 => Index: 40. Node size: 2. Addr: 107614700568848. 
            - 1 => Index: 81. Node size: 1. Addr: 107614700568848. 
            - 1 => Index: 82. Node size: 1. Addr: 107614700568856. 
        - 3 => Index: 20. Node size: 4. Addr: 107614700568864. 
          - 2 => Index: 41. Node size: 2. Addr: 107614700568864. 
            - 1 => Index: 83. Node size: 1. Addr: 107614700568864. 
            - 1 => Index: 84. Node size: 1. Addr: 107614700568872. 
          - 2 => Index: 42. Node size: 2. Addr: 107614700568880. 
            - 1 => Index: 85. Node size: 1. Addr: 107614700568880. 
            - 1 => Index: 86. Node size: 1. Addr: 107614700568888. 
      - 4 => Index: 10. Node size: 8. Addr: 107614700568896. 
        - 3 => Index: 21. Node size: 4. Addr: 107614700568896. 
          - 2 => Index: 43. Node size: 2. Addr: 107614700568896. 
            - 1 => Index: 87. Node size: 1. Addr: 107614700568896. 
            - 1 => Index: 88. Node size: 1. Addr: 107614700568904. 
          - 2 => Index: 44. Node size: 2. Addr: 107614700568912. 
            - 1 => Index: 89. Node size: 1. Addr: 107614700568912. 
            - 1 => Index: 90. Node size: 1. Addr: 107614700568920. 
        - 3 => Index: 22. Node size: 4. Addr: 107614700568928. 
          - 2 => Index: 45. Node size: 2. Addr: 107614700568928. 
            - 1 => Index: 91. Node size: 1. Addr: 107614700568928. 
            - 1 => Index: 92. Node size: 1. Addr: 107614700568936. 
          - 2 => Index: 46. Node size: 2. Addr: 107614700568944. 
            - 1 => Index: 93. Node size: 1. Addr: 107614700568944. 
            - 1 => Index: 94. Node size: 1. Addr: 107614700568952. 
  - 6 => Index: 2. Node size: 32. Addr: 107614700568960. 
    - 5 => Index: 5. Node size: 16. Addr: 107614700568960. 
      - 4 => Index: 11. Node size: 8. Addr: 107614700568960. 
        - 3 => Index: 23. Node size: 4. Addr: 107614700568960. 
          - 2 => Index: 47. Node size: 2. Addr: 107614700568960. 
            - 1 => Index: 95. Node size: 1. Addr: 107614700568960. 
            - 1 => Index: 96. Node size: 1. Addr: 107614700568968. 
          - 2 => Index: 48. Node size: 2. Addr: 107614700568976. 
            - 1 => Index: 97. Node size: 1. Addr: 107614700568976. 
            - 1 => Index: 98. Node size: 1. Addr: 107614700568984. 
        - 3 => Index: 24. Node size: 4. Addr: 107614700568992. 
          - 2 => Index: 49. Node size: 2. Addr: 107614700568992. 
            - 1 => Index: 99. Node size: 1. Addr: 107614700568992. 
            - 1 => Index: 100. Node size: 1. Addr: 107614700569000. 
          - 2 => Index: 50. Node size: 2. Addr: 107614700569008. 
            - 1 => Index: 101. Node size: 1. Addr: 107614700569008. 
            - 1 => Index: 102. Node size: 1. Addr: 107614700569016. 
      - 4 => Index: 12. Node size: 8. Addr: 107614700569024. 
        - 3 => Index: 25. Node size: 4. Addr: 107614700569024. 
          - 2 => Index: 51. Node size: 2. Addr: 107614700569024. 
            - 1 => Index: 103. Node size: 1. Addr: 107614700569024. 
            - 1 => Index: 104. Node size: 1. Addr: 107614700569032. 
          - 2 => Index: 52. Node size: 2. Addr: 107614700569040. 
            - 1 => Index: 105. Node size: 1. Addr: 107614700569040. 
            - 1 => Index: 106. Node size: 1. Addr: 107614700569048. 
        - 3 => Index: 26. Node size: 4. Addr: 107614700569056. 
          - 2 => Index: 53. Node size: 2. Addr: 107614700569056. 
            - 1 => Index: 107. Node size: 1. Addr: 107614700569056. 
            - 1 => Index: 108. Node size: 1. Addr: 107614700569064. 
          - 2 => Index: 54. Node size: 2. Addr: 107614700569072. 
            - 1 => Index: 109. Node size: 1. Addr: 107614700569072. 
            - 1 => Index: 110. Node size: 1. Addr: 107614700569080. 
    - 5 => Index: 6. Node size: 16. Addr: 107614700569088. 
      - 4 => Index: 13. Node size: 8. Addr: 107614700569088. 
        - 3 => Index: 27. Node size: 4. Addr: 107614700569088. 
          - 2 => Index: 55. Node size: 2. Addr: 107614700569088. 
            - 1 => Index: 111. Node size: 1. Addr: 107614700569088. 
            - 1 => Index: 112. Node size: 1. Addr: 107614700569096. 
          - 2 => Index: 56. Node size: 2. Addr: 107614700569104. 
            - 1 => Index: 113. Node size: 1. Addr: 107614700569104. 
            - 1 => Index: 114. Node size: 1. Addr: 107614700569112. 
        - 3 => Index: 28. Node size: 4. Addr: 107614700569120. 
          - 2 => Index: 57. Node size: 2. Addr: 107614700569120. 
            - 1 => Index: 115. Node size: 1. Addr: 107614700569120. 
            - 1 => Index: 116. Node size: 1. Addr: 107614700569128. 
          - 2 => Index: 58. Node size: 2. Addr: 107614700569136. 
            - 1 => Index: 117. Node size: 1. Addr: 107614700569136. 
            - 1 => Index: 118. Node size: 1. Addr: 107614700569144. 
      - 4 => Index: 14. Node size: 8. Addr: 107614700569152. 
        - 3 => Index: 29. Node size: 4. Addr: 107614700569152. 
          - 2 => Index: 59. Node size: 2. Addr: 107614700569152. 
            - 1 => Index: 119. Node size: 1. Addr: 107614700569152. 
            - 1 => Index: 120. Node size: 1. Addr: 107614700569160. 
          - 2 => Index: 60. Node size: 2. Addr: 107614700569168. 
            - 1 => Index: 121. Node size: 1. Addr: 107614700569168. 
            - 1 => Index: 122. Node size: 1. Addr: 107614700569176. 
        - 3 => Index: 30. Node size: 4. Addr: 107614700569184. 
          - 2 => Index: 61. Node size: 2. Addr: 107614700569184. 
            - 1 => Index: 123. Node size: 1. Addr: 107614700569184. 
            - 1 => Index: 124. Node size: 1. Addr: 107614700569192. 
          - 2 => Index: 62. Node size: 2. Addr: 107614700569200. 
            - 1 => Index: 125. Node size: 1. Addr: 107614700569200. 
            - 1 => Index: 126. Node size: 1. Addr: 107614700569208. 

Task Memory Alloc: 
PID: 0; Need size: 6; State: 2; Addr: 107614700568712; Real size: 8. 
PID: 1; Need size: 20; State: 2; Addr: 107614700568968; Real size: 32. 
PID: 2; Need size: 25; State: -1. 
PID: 3; Need size: 4; State: 2; Addr: 107614700568840; Real size: 8. 

MemAlloc Tree: 
- 7 => Index: 0. Node size: 8. Addr: 107614700568704. 
  - 6 => Index: 1. Node size: 8. Addr: 107614700568704. 
    - 5 => Index: 3. Node size: 8. Addr: 107614700568704. 
      - 4 => Index: 7. Node size: 0. Addr: 107614700568704. 
      - 4 => Index: 8. Node size: 8. Addr: 107614700568768. 
        - 3 => Index: 17. Node size: 4. Addr: 107614700568768. 
          - 2 => Index: 35. Node size: 2. Addr: 107614700568768. 
            - 1 => Index: 71. Node size: 1. Addr: 107614700568768. 
            - 1 => Index: 72. Node size: 1. Addr: 107614700568776. 
          - 2 => Index: 36. Node size: 2. Addr: 107614700568784. 
            - 1 => Index: 73. Node size: 1. Addr: 107614700568784. 
            - 1 => Index: 74. Node size: 1. Addr: 107614700568792. 
        - 3 => Index: 18. Node size: 4. Addr: 107614700568800. 
          - 2 => Index: 37. Node size: 2. Addr: 107614700568800. 
            - 1 => Index: 75. Node size: 1. Addr: 107614700568800. 
            - 1 => Index: 76. Node size: 1. Addr: 107614700568808. 
          - 2 => Index: 38. Node size: 2. Addr: 107614700568816. 
            - 1 => Index: 77. Node size: 1. Addr: 107614700568816. 
            - 1 => Index: 78. Node size: 1. Addr: 107614700568824. 
    - 5 => Index: 4. Node size: 8. Addr: 107614700568832. 
      - 4 => Index: 9. Node size: 0. Addr: 107614700568832. 
      - 4 => Index: 10. Node size: 8. Addr: 107614700568896. 
        - 3 => Index: 21. Node size: 4. Addr: 107614700568896. 
          - 2 => Index: 43. Node size: 2. Addr: 107614700568896. 
            - 1 => Index: 87. Node size: 1. Addr: 107614700568896. 
            - 1 => Index: 88. Node size: 1. Addr: 107614700568904. 
          - 2 => Index: 44. Node size: 2. Addr: 107614700568912. 
            - 1 => Index: 89. Node size: 1. Addr: 107614700568912. 
            - 1 => Index: 90. Node size: 1. Addr: 107614700568920. 
        - 3 => Index: 22. Node size: 4. Addr: 107614700568928. 
          - 2 => Index: 45. Node size: 2. Addr: 107614700568928. 
            - 1 => Index: 91. Node size: 1. Addr: 107614700568928. 
            - 1 => Index: 92. Node size: 1. Addr: 107614700568936. 
          - 2 => Index: 46. Node size: 2. Addr: 107614700568944. 
            - 1 => Index: 93. Node size: 1. Addr: 107614700568944. 
            - 1 => Index: 94. Node size: 1. Addr: 107614700568952. 
  - 6 => Index: 2. Node size: 0. Addr: 107614700568960. 

Task Memory Dealloc: 
PID: 0; Need size: 6; State: 0. 
PID: 1; Need size: 20; State: 0. 
PID: 2; Need size: 25; State: -1. 
PID: 3; Need size: 4; State: 0. 

MemAlloc Tree: 
- 7 => Index: 0. Node size: 64. Addr: 107614700568704. 
  - 6 => Index: 1. Node size: 32. Addr: 107614700568704. 
    - 5 => Index: 3. Node size: 16. Addr: 107614700568704. 
      - 4 => Index: 7. Node size: 8. Addr: 107614700568704. 
        - 3 => Index: 15. Node size: 4. Addr: 107614700568704. 
          - 2 => Index: 31. Node size: 2. Addr: 107614700568704. 
            - 1 => Index: 63. Node size: 1. Addr: 107614700568704. 
            - 1 => Index: 64. Node size: 1. Addr: 107614700568712. 
          - 2 => Index: 32. Node size: 2. Addr: 107614700568720. 
            - 1 => Index: 65. Node size: 1. Addr: 107614700568720. 
            - 1 => Index: 66. Node size: 1. Addr: 107614700568728. 
        - 3 => Index: 16. Node size: 4. Addr: 107614700568736. 
          - 2 => Index: 33. Node size: 2. Addr: 107614700568736. 
            - 1 => Index: 67. Node size: 1. Addr: 107614700568736. 
            - 1 => Index: 68. Node size: 1. Addr: 107614700568744. 
          - 2 => Index: 34. Node size: 2. Addr: 107614700568752. 
            - 1 => Index: 69. Node size: 1. Addr: 107614700568752. 
            - 1 => Index: 70. Node size: 1. Addr: 107614700568760. 
      - 4 => Index: 8. Node size: 8. Addr: 107614700568768. 
        - 3 => Index: 17. Node size: 4. Addr: 107614700568768. 
          - 2 => Index: 35. Node size: 2. Addr: 107614700568768. 
            - 1 => Index: 71. Node size: 1. Addr: 107614700568768. 
            - 1 => Index: 72. Node size: 1. Addr: 107614700568776. 
          - 2 => Index: 36. Node size: 2. Addr: 107614700568784. 
            - 1 => Index: 73. Node size: 1. Addr: 107614700568784. 
            - 1 => Index: 74. Node size: 1. Addr: 107614700568792. 
        - 3 => Index: 18. Node size: 4. Addr: 107614700568800. 
          - 2 => Index: 37. Node size: 2. Addr: 107614700568800. 
            - 1 => Index: 75. Node size: 1. Addr: 107614700568800. 
            - 1 => Index: 76. Node size: 1. Addr: 107614700568808. 
          - 2 => Index: 38. Node size: 2. Addr: 107614700568816. 
            - 1 => Index: 77. Node size: 1. Addr: 107614700568816. 
            - 1 => Index: 78. Node size: 1. Addr: 107614700568824. 
    - 5 => Index: 4. Node size: 16. Addr: 107614700568832. 
      - 4 => Index: 9. Node size: 8. Addr: 107614700568832. 
        - 3 => Index: 19. Node size: 4. Addr: 107614700568832. 
          - 2 => Index: 39. Node size: 2. Addr: 107614700568832. 
            - 1 => Index: 79. Node size: 1. Addr: 107614700568832. 
            - 1 => Index: 80. Node size: 1. Addr: 107614700568840. 
          - 2 => Index: 40. Node size: 2. Addr: 107614700568848. 
            - 1 => Index: 81. Node size: 1. Addr: 107614700568848. 
            - 1 => Index: 82. Node size: 1. Addr: 107614700568856. 
        - 3 => Index: 20. Node size: 4. Addr: 107614700568864. 
          - 2 => Index: 41. Node size: 2. Addr: 107614700568864. 
            - 1 => Index: 83. Node size: 1. Addr: 107614700568864. 
            - 1 => Index: 84. Node size: 1. Addr: 107614700568872. 
          - 2 => Index: 42. Node size: 2. Addr: 107614700568880. 
            - 1 => Index: 85. Node size: 1. Addr: 107614700568880. 
            - 1 => Index: 86. Node size: 1. Addr: 107614700568888. 
      - 4 => Index: 10. Node size: 8. Addr: 107614700568896. 
        - 3 => Index: 21. Node size: 4. Addr: 107614700568896. 
          - 2 => Index: 43. Node size: 2. Addr: 107614700568896. 
            - 1 => Index: 87. Node size: 1. Addr: 107614700568896. 
            - 1 => Index: 88. Node size: 1. Addr: 107614700568904. 
          - 2 => Index: 44. Node size: 2. Addr: 107614700568912. 
            - 1 => Index: 89. Node size: 1. Addr: 107614700568912. 
            - 1 => Index: 90. Node size: 1. Addr: 107614700568920. 
        - 3 => Index: 22. Node size: 4. Addr: 107614700568928. 
          - 2 => Index: 45. Node size: 2. Addr: 107614700568928. 
            - 1 => Index: 91. Node size: 1. Addr: 107614700568928. 
            - 1 => Index: 92. Node size: 1. Addr: 107614700568936. 
          - 2 => Index: 46. Node size: 2. Addr: 107614700568944. 
            - 1 => Index: 93. Node size: 1. Addr: 107614700568944. 
            - 1 => Index: 94. Node size: 1. Addr: 107614700568952. 
  - 6 => Index: 2. Node size: 32. Addr: 107614700568960. 
    - 5 => Index: 5. Node size: 16. Addr: 107614700568960. 
      - 4 => Index: 11. Node size: 8. Addr: 107614700568960. 
        - 3 => Index: 23. Node size: 4. Addr: 107614700568960. 
          - 2 => Index: 47. Node size: 2. Addr: 107614700568960. 
            - 1 => Index: 95. Node size: 1. Addr: 107614700568960. 
            - 1 => Index: 96. Node size: 1. Addr: 107614700568968. 
          - 2 => Index: 48. Node size: 2. Addr: 107614700568976. 
            - 1 => Index: 97. Node size: 1. Addr: 107614700568976. 
            - 1 => Index: 98. Node size: 1. Addr: 107614700568984. 
        - 3 => Index: 24. Node size: 4. Addr: 107614700568992. 
          - 2 => Index: 49. Node size: 2. Addr: 107614700568992. 
            - 1 => Index: 99. Node size: 1. Addr: 107614700568992. 
            - 1 => Index: 100. Node size: 1. Addr: 107614700569000. 
          - 2 => Index: 50. Node size: 2. Addr: 107614700569008. 
            - 1 => Index: 101. Node size: 1. Addr: 107614700569008. 
            - 1 => Index: 102. Node size: 1. Addr: 107614700569016. 
      - 4 => Index: 12. Node size: 8. Addr: 107614700569024. 
        - 3 => Index: 25. Node size: 4. Addr: 107614700569024. 
          - 2 => Index: 51. Node size: 2. Addr: 107614700569024. 
            - 1 => Index: 103. Node size: 1. Addr: 107614700569024. 
            - 1 => Index: 104. Node size: 1. Addr: 107614700569032. 
          - 2 => Index: 52. Node size: 2. Addr: 107614700569040. 
            - 1 => Index: 105. Node size: 1. Addr: 107614700569040. 
            - 1 => Index: 106. Node size: 1. Addr: 107614700569048. 
        - 3 => Index: 26. Node size: 4. Addr: 107614700569056. 
          - 2 => Index: 53. Node size: 2. Addr: 107614700569056. 
            - 1 => Index: 107. Node size: 1. Addr: 107614700569056. 
            - 1 => Index: 108. Node size: 1. Addr: 107614700569064. 
          - 2 => Index: 54. Node size: 2. Addr: 107614700569072. 
            - 1 => Index: 109. Node size: 1. Addr: 107614700569072. 
            - 1 => Index: 110. Node size: 1. Addr: 107614700569080. 
    - 5 => Index: 6. Node size: 16. Addr: 107614700569088. 
      - 4 => Index: 13. Node size: 8. Addr: 107614700569088. 
        - 3 => Index: 27. Node size: 4. Addr: 107614700569088. 
          - 2 => Index: 55. Node size: 2. Addr: 107614700569088. 
            - 1 => Index: 111. Node size: 1. Addr: 107614700569088. 
            - 1 => Index: 112. Node size: 1. Addr: 107614700569096. 
          - 2 => Index: 56. Node size: 2. Addr: 107614700569104. 
            - 1 => Index: 113. Node size: 1. Addr: 107614700569104. 
            - 1 => Index: 114. Node size: 1. Addr: 107614700569112. 
        - 3 => Index: 28. Node size: 4. Addr: 107614700569120. 
          - 2 => Index: 57. Node size: 2. Addr: 107614700569120. 
            - 1 => Index: 115. Node size: 1. Addr: 107614700569120. 
            - 1 => Index: 116. Node size: 1. Addr: 107614700569128. 
          - 2 => Index: 58. Node size: 2. Addr: 107614700569136. 
            - 1 => Index: 117. Node size: 1. Addr: 107614700569136. 
            - 1 => Index: 118. Node size: 1. Addr: 107614700569144. 
      - 4 => Index: 14. Node size: 8. Addr: 107614700569152. 
        - 3 => Index: 29. Node size: 4. Addr: 107614700569152. 
          - 2 => Index: 59. Node size: 2. Addr: 107614700569152. 
            - 1 => Index: 119. Node size: 1. Addr: 107614700569152. 
            - 1 => Index: 120. Node size: 1. Addr: 107614700569160. 
          - 2 => Index: 60. Node size: 2. Addr: 107614700569168. 
            - 1 => Index: 121. Node size: 1. Addr: 107614700569168. 
            - 1 => Index: 122. Node size: 1. Addr: 107614700569176. 
        - 3 => Index: 30. Node size: 4. Addr: 107614700569184. 
          - 2 => Index: 61. Node size: 2. Addr: 107614700569184. 
            - 1 => Index: 123. Node size: 1. Addr: 107614700569184. 
            - 1 => Index: 124. Node size: 1. Addr: 107614700569192. 
          - 2 => Index: 62. Node size: 2. Addr: 107614700569200. 
            - 1 => Index: 125. Node size: 1. Addr: 107614700569200. 
            - 1 => Index: 126. Node size: 1. Addr: 107614700569208. 
```



## 7. 源代码

```c
// mem.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

#define TEST_ALLOC_SIZE (1LL << 6)
#define TEST_TASK 4

#ifdef LOCAL_DEBUG
#define DEBUG(FMT, ...) { char buf[1 << 10]; sprintf(buf, FMT, __VA_ARGS__); fprintf(stderr, "In Func: %s; Line %d; Msg => %s \n", __FUNCTION__, __LINE__, buf); }
#else
#define DEBUG(...)
#endif

typedef int32_t i32;
typedef int64_t i64;

typedef uint32_t u32;
typedef uint64_t u64;

struct FreeBlock {
    u64 size;  // 如果该位置可用，那么 size == levelSize ，否则 size = max(lc.size, rc.size) 或 0
    u64 *addr; // 数组起点 
};

struct MemAlloc {
    u64 totSize;  // 内存池总大小
    u64 *startAddr;  // 内存池起始地址
    struct FreeBlock *freeList;  // 满二叉树管理内存位置
};

// 计算 size 目前的等级
u64 GetSizeLevel(u64 size) {
    u64 level = 0;
    while (size > 0) {
        level ++;
        size >>= 1;
    }
    return level;
}

// 计算左节点位置
u64 __GetLeftChildIndex(u64 parentIndex) {
    return parentIndex * 2 + 1;
}
// 计算右节点位置
u64 __GetRigntChildIndex(u64 parentIndex) {
    return parentIndex * 2 + 2;
}
// 计算父亲节点位置
u64 __GetParentIndex(u64 childIndex) {
    return (childIndex + 1) / 2 - 1;
}

// 判断是否是 2^X
i32 __IsPowerOf2(u64 size) {
    return !(size & (size - 1));
}

// 调整 size 为 最小的 2^X > size
u64 __FixSize64(u64 size) {
    size |= size >> 1;
    size |= size >> 2;
    size |= size >> 4;
    size |= size >> 8;
    size |= size >> 16;
    size |= size >> 32;
    return size + 1;
}

// 初始化二叉树所有信息
void __FreeBlockListAddrInit(struct FreeBlock *freeList, u64 index, u64 *startAddr, u64 size) {
    // 初始化节点信息
    freeList[index].size = size;
    freeList[index].addr = startAddr;

    // 最小分配内存大小节点为 1
    if (size == 1) {
        return;
    }

    // 分配左右节点
    __FreeBlockListAddrInit(freeList, __GetLeftChildIndex(index), startAddr, size / 2);
    __FreeBlockListAddrInit(freeList, __GetRigntChildIndex(index), &startAddr[size / 2], size / 2);
}

// 内存适配器 构造函数
i32 MemAllocInit(struct MemAlloc *this, u64 size) {
    // 判断当前对象是否合法
    // 判断当前分配内存是否合法
    if (this == NULL || size == 0 || !__IsPowerOf2(size)) {
        return -1;
    }

    // 申请连续空间
    // [0, size - 1] 为 内存池
    // 从 size 开始的 [0, 2 * size - 1] 为二叉树
    u64 *addr = (u64*)malloc(
            sizeof(u64) * size 
            + (size * 2 - 1) * sizeof(struct FreeBlock)
        );

    // 申请内存失败
    if (addr == NULL) {
        return -1;
    }
    
    // 初始化 allocator
    this->totSize = size;
    // 分配地址
    this->startAddr = addr;
    this->freeList = (struct FreeBlock*)(&(addr[size]));

    // 初始化 freeList
    __FreeBlockListAddrInit(this->freeList, 0, addr, size);
    
    return 0;
}

// 内存适配器 析构函数
void MemAllocDel(struct MemAlloc *this) {
    free(this->startAddr);
    this->startAddr = NULL;
}

// 查找二叉树数组索引下的下标位置
// 需要保证一定有剩余的可分配内存
u64 __FindFreeMemAddr(struct FreeBlock *freeList, u64 index, u64 needSize, u64 levelSize) {
    if (needSize == levelSize) {
        return index;
    }
    
    // 计算孩子节点
    u64 lc = __GetLeftChildIndex(index), rc = __GetRigntChildIndex(index);
    // 如果两边的剩余内存都符合
    if (freeList[lc].size >= needSize && freeList[rc].size >= needSize) {
        // 找一个剩余空间大的
        if (freeList[lc].size >= freeList[rc].size) {
            return __FindFreeMemAddr(freeList, lc, needSize, levelSize >> 1);
        } else {
            return __FindFreeMemAddr(freeList, rc, needSize, levelSize >> 1);
        }
    // 否则找其中符合的
    } else if (freeList[lc].size >= needSize) {
        return __FindFreeMemAddr(freeList, lc, needSize, levelSize >> 1);
    } else {
        return __FindFreeMemAddr(freeList, rc, needSize, levelSize >> 1);
    }
}

// 重新向上计算大小信息
// 不合并内存
void __RecalcFreeListSize(struct FreeBlock *freeList, u64 index) {
    DEBUG("Index: %lu", index);

    u64 parentIndex = __GetParentIndex(index);
    u64 lc = __GetLeftChildIndex(parentIndex), rc = __GetRigntChildIndex(parentIndex);

    freeList[parentIndex].size 
        = freeList[lc].size >= freeList[rc].size ? freeList[lc].size : freeList[rc].size;
    
    if (parentIndex > 0) {
        __RecalcFreeListSize(freeList, parentIndex);
    }
}

// 分配大小为 size 的内存
// 要求 size 符合条件
void* __MemAlloc(struct MemAlloc *this, u64 size) {
    // 找到存在剩余内存的下标
    u64 index = __FindFreeMemAddr(this->freeList, 0, size, this->totSize);
    
    // 将这个节点的内存大小标志为 0
    // 表示该位置已经分配内存
    this->freeList[index].size = 0;

    // 分配后重新调整树的信息
    if (index > 0)
        __RecalcFreeListSize(this->freeList, index);

    return (void*)this->freeList[index].addr;
}

// 正式分配内存
void* MemAlloc(struct MemAlloc *this, u64 size) {
    // 调整符合的内存
    // 需要额外空间存储分配的大小
    size = __FixSize64(size + 1);
    
    // 判断请求分配的内存空间是否超过目前可以分配的最大内存块
    if (this->freeList[0].size < size) {
        return NULL;
    }

    // 调用分配
    u64 *addr = (u64*)__MemAlloc(this, size);

    // 初始位置存储分配内存总大小
    // 方便释放内存
    *addr = size;
    
    return (void*)(&addr[1]);
}

// 查找到合适的分配内存位置
u64 __FindAllocAddrIndex(struct FreeBlock *freeList, u64 *addr, u64 index, u64 tagetSize, u64 levelSize) {
    DEBUG("Index: %lu; TargetSize: %lu; LevelSize: %lu", index, tagetSize, levelSize);
    // 如果这个节点是目标节点
    if (tagetSize == levelSize) {
        return index;
    }

    // 向下继续寻找
    u64 lc = __GetLeftChildIndex(index), rc = __GetRigntChildIndex(index);
    DEBUG("LC: size %lu, addr %lu; RC: size %lu, addr %lu", freeList[lc].size, freeList[lc].addr, freeList[rc].size, freeList[rc].addr);
    // 通过指针偏移位置来确定位置
    if (freeList[rc].addr > addr) {
        return __FindAllocAddrIndex(freeList, addr, lc, tagetSize, levelSize >> 1);
    } else {
        return __FindAllocAddrIndex(freeList, addr, rc, tagetSize, levelSize >> 1);
    }
}

// 向上更新树的信息
// 带有内存块合并
void __RecalcFreeListSizeWithMerge(struct FreeBlock *freeList, u64 index, u64 levelSize) {
    DEBUG("Index: %lu; LevelSize: %lu", index, levelSize);
    u64 parentIndex = __GetParentIndex(index);
    u64 lc = __GetLeftChildIndex(parentIndex), rc = __GetRigntChildIndex(parentIndex);

    // 如果孩子的内存都是空的 那么就可以合并
    if (freeList[lc].size == levelSize && freeList[rc].size == levelSize) {
        freeList[parentIndex].size = levelSize << 1;
    } else {
        // 否则更新最大值
        freeList[parentIndex].size 
            = freeList[lc].size >= freeList[rc].size 
                ? freeList[lc].size : freeList[rc].size;
    }

    // 如果还没到根节点
    if (parentIndex > 0) {
        __RecalcFreeListSizeWithMerge(freeList, parentIndex, levelSize << 1);
    }
}

// 归还内存
// 要求传入的地址与分配时的地址是符合的
void MemDealloc(struct MemAlloc *this, u64 *allocAddr) {
    // 计算分配时内存地址位置
    u64 *addr = &(allocAddr[-1]);
    // 获取分配时内存块大小
    u64 size = *addr;

    // 查找被分配的节点位置
    u64 index = __FindAllocAddrIndex(this->freeList, addr, 0, size, this->totSize);
    DEBUG("Index: %lu", index);
    assert(this->freeList[index].size == 0);

    // 归还内存 并重新调整树上信息
    this->freeList[index].size = size;
    if (index > 0)
        __RecalcFreeListSizeWithMerge(this->freeList, index, size);
}

// 打印树上的信息
void DfsPrint(struct FreeBlock *freeList, u64 index, u64 level, int tabShift) {
    struct FreeBlock *now = &freeList[index];
    for (int i = 0; i < tabShift; i ++) {
        printf(" ");
    }
    printf("- %lu => Index: %lu. Node size: %lu. Addr: %lu. \n", level, index, now->size, (u64)now->addr);
    if (level == 1 || now->size == 0) {
        return;
    }
    DfsPrint(freeList, __GetLeftChildIndex(index), level - 1, tabShift + 2);
    DfsPrint(freeList, __GetRigntChildIndex(index), level - 1, tabShift + 2);
}

// 进程信息记录
struct TaskInfo {
    i32 state;  // 进程状态 1 := 待分配 2 := 分配完成 0 := 进程结束 -1 := 分配失败
    u64 pid;  // 进程标识符
    u64 needSize;  // 进程所需要的内存大小
    u64 realSize;  // 进程实际被分配的内存大小
    void *addr;  // 分配的地址
};

void TaskInfoInit(struct TaskInfo *this, u64 pid, u64 needSize) {
    this->pid = pid;
    this->needSize = needSize;
    
    this->state = 0;
    this->realSize = -1;
    this->addr = NULL;
}

void __TaskInit(struct TaskInfo *this) {
    u64 pid, needSize;
    scanf("%lu %lu", &pid, &needSize);
    TaskInfoInit(this, pid, needSize);
}
void __TaskFormatPrint(struct TaskInfo *this) {
    if (this->state != 2) {
        printf("PID: %lu; Need size: %lu; State: %d. \n", this->pid, this->needSize, this->state);
    } else {
        printf("PID: %lu; Need size: %lu; State: %d; Addr: %lu; Real size: %lu. \n", 
                this->pid, this->needSize, this->state, (u64)this->addr, this->realSize);
    }
}

void TestTask() {
    struct MemAlloc memAlloc;
    if (MemAllocInit(&memAlloc, TEST_ALLOC_SIZE) == -1) {
        printf("Alloc init failure. \n");
        return;
    }

#define PRINT_MEM_ALLOC_LIST puts("MemAlloc Tree: "); DfsPrint(memAlloc.freeList, 0, GetSizeLevel(memAlloc.totSize), 0); puts("")

    PRINT_MEM_ALLOC_LIST;

    struct TaskInfo task[TEST_TASK];

    printf("Task Init: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        __TaskInit(&task[i]);
        __TaskFormatPrint(&task[i]);
    }
    puts("");
    
    PRINT_MEM_ALLOC_LIST;

    printf("Task Memory Alloc: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        u64* addr = (u64*)MemAlloc(&memAlloc, task[i].needSize);
        DEBUG("addr: %lu", (u64)(&(addr[-1])));
        if (addr == NULL) {
            task[i].state = -1;
        } else {
            task[i].addr = addr;
            task[i].realSize = addr[-1];
            task[i].state = 2;
        }
        __TaskFormatPrint(&task[i]);
    }
    puts("");

    PRINT_MEM_ALLOC_LIST;

    printf("Task Memory Dealloc: \n");
    for (int i = 0; i < TEST_TASK; i ++) {
        DEBUG("Tast: %d", i);
        if (task[i].state == 2) {
            MemDealloc(&memAlloc, task[i].addr);
            task[i].state = 0;
        }
        __TaskFormatPrint(&task[i]);
    }
    puts("");

    PRINT_MEM_ALLOC_LIST;

    MemAllocDel(&memAlloc);

#undef PRINT_MEM_ALLOC_LIST
}

int main() {
    int n;
    scanf("%d", &n);
    
    for (int i = 0; i < n; i ++) {
        char fd[100];
        sprintf(fd, "out/%d.txt", i);
        freopen(fd, "w+", stdout);
        TestTask();
    }
}
```

```cpp
// test.cpp
#include <bits/stdc++.h>

int main() {
    constexpr int size_limit = 1 << 5;


    std::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());

    int tot_test;
    std::cin >> tot_test;

    std::cout << tot_test << '\n';
    for (int i = 0; i < tot_test; i ++) {
        for (int i = 0; i < 4; i ++) {
            auto pid = i;
            auto need_size = rnd() % size_limit + 1;
            std::cout << pid << ' ' << need_size << '\n';
        }
    }
}

```

