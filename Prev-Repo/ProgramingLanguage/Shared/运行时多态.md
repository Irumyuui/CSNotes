# 运行时多态

## 静态多态

很多时候，我们都会遇到一种情况：

```c++
void foo(...? x) {
    x.dump();
}
```

我们不知道 `x` 是什么类型，但是我们需要它有一个方法：`dump` 。那么，如果你是编译期内狂魔，你应该知道这是怎么个做法。

```c++
template <typename T>
    requries requires(T t) { {t.dump()} }
void foo(T x) {
    x.dump();
}
```

看起来很好，对吧？但是实际上对于这份代码，它只会在编译期间内生成对应的代码。

```c++
struct A { void dump() {} };
struct B { void dump() {} };

// 编译后的代码看起来像这样
void foo_A(A x) { x.dump(); }
void foo_B(B x) { x.dump(); }
```

看起来很美好，是吗。假如我们不考虑其他的，那确实是一个很好的做法，也没有什么问题。但是，如果我们考虑到**副作用**，比如 `IO` ，又或者是我这个编译单元没为其他编译单元中满足条件的类型生成这段代码，那么就出现问题了。

解决方法还是有的，也就是运行时再来判断类型信息就好了。

## 继承实现运行时多态

OOP 总用人说三大特征：继承、封装、多态。然而实际上，真正重要的，是封装和多态。前者保证了数据的抽象，后者则可以解决上述的问题。

对于比较有历史的语言来说，选择的实现方式很多为继承实现。

```c++
struct Base {
    void dump();
};
struct Derived : public Base {
    //
};
```

为了能在运行时查找到正确的方法，我们需要一个表来实现，也就是**虚函数表**。

```c++
struct Base {
    virtual ~Base() = default;
    virtual void dump();
};
struct Derived : public Base {
    void dump() override;
};
```

在每个含有虚函数的对象中，其内存布局的开头一个指针的大小被塞入了一个指针，指向虚函数表。这样，对于这一类的对象来说，运行时执行虚函数需要通过这个指针查找到正确的虚函数实现，即也就是所谓的**多态**。

> 构造函数不需要为虚函数吗？ \
> 不需要也不能被声明为虚函数，因为在构造对象的时候对象的类型已经确定，不需要多态。

> 如果存在虚函数，析构函数为什么一定也要为虚函数？ \
> 因为此时类型展现出了多态性，如果析构函数不为多态，那么此时对象析构时其类成员就可能不被正常析构。

但是可以看出来，采用这种方式，如果没有用到虚函数，或者没有用到多态性，依然要为这一部分特性支付额外的内存开销，并且，如果没有多态性且调用虚函数，那么依然还是要查表，这就造成了额外的性能开销。

## 胖指针实现运行时多态

像 `rust` 则采用了另外一种实现多态的方式：胖指针。

> 胖指针是指代一些具有动态大小类型的引用或者原始指针，这些对象的类型大小无法在编译期内确定，但可以在运行时确定。

```rust
trait Dump {
    fn dump(&self);
}

struct Foo;
struct Bar;

impl Dump for Foo {
    fn dump(&self) {
        println!("Foo");
    }
}

impl Dump for Bar {
    fn dump(&self) {
        println!("Bar");
    }
}

fn dump_it(obj: &dyn Dump) {
    obj.dump();
}

fn main() {
    dump_it(&Foo {});
    dump_it(&Bar {});
}
```

胖指针的实现方式和继承的方式不同，其指针大小为两个正常指针大小，其中一个指针指向这个对象，另外一个指针指向一些额外的信息。对于我们的 `trait object` 来说，它所保存的信息即为一个指向该对象的指针与一个指向该对象的虚表指针。

这样实现的好处在于，**`struct` 的内存布局没发生改变**。回想 `c++` 的继承实现，此时每个对象的内存布局中一定被塞入了一个指向虚表的指针，但是并不是所有时候都会用到这个指针。而如果像是 `rust` 的胖指针实现，基础的内存布局不会额外带入一个虚表指针，而是**当你需要用到多态时才会附带上这个代价**。

## 这世界很美好吗？

看起来胖指针的方式很完美，不是吗？**你不需要为你所用不到的功能付出代价**。但是别忘了，**没有银弹**，还得等 `dyn upcast` 提案通过。
