# 动态链接库的加载

相对于静态链接，动态链接的不会将其他的可执行代码一并合入到可执行文件中，而是在运行时加载所需的库，**多个程序就可以共享同一个库的单一副本了**。

## 动态链接器

动态链接的过程并不是由我们自己在代码编写时装载的，至少不需要你在代码中显式写明，而是交给**动态链接器**来完成，你只需要在构建时指明需要的动态链接库即可。对于 `Linux` 来说，它的动态链接器为 `ld.so` 或者 `ld-linux.so` ，可见它也是一个动态库。

当一个程序运行、执行到需要动态链接的地方时，这时候就需要动态链接器来加载这些动态链接库，并解析其中的符号引用和重定位地址。

## 动态链接工作原理

当一个程序请求加载动态链接库时，操作系统则通过动态链接器来将所需的库装载到内存中。

1. 加载动态链接器：实际上，动态链接器也是一个动态链接库，最开始是由它来完成所有的动态链接工作。
2. 解析库依赖：动态链接器解析该程序的头部，并找到指定程序依赖的所有共享库。
3. 加载库：动态链接器加载所需的共享库，并将其映射到内存中。
4. 符号解析、地址重定位：这一步，动态链接器解析符号引用，并将其映射到内存中的实际地址。

本质上，动态链接就是运行时动态加载外部模块。因此，可以照着这个思路分析其优点和缺点在哪里。

- 优点
  - 节省内存
  - 与程序实现解耦
  - 可执行文件小
- 缺点
  - 无法确保库是否存在
  - 无法确保库版本兼容性
  - 需要额外加载时间

对于动态链接的程序，一个最大优点即为**可执行文件小**，因为不同的可执行文件若依赖同一个库，那么这个库只需要存在一个即可。同时，因为库与程序是分离的，因此可以两个版本各自更新自己的，不需要同时更新。但这也引出了一个问题，如果库的 `abi` 不兼容，那么程序可能崩溃，同时也无法确保用户平台上是否存在这个库，这也是经常可以看到提示缺少 `dll` 的一个原因。

## 动态链接库的查找

如果是类 `UNIX` 系统，那么查找动态链接库时会找这以下路径：

1. `RPATH`，即运行时路径，通过 `ld` 的 `-rpath` 参数指定，可以指定多个路径，多个路径之间用冒号分隔。
2. `LD_LIBRARY_PATH`，即环境变量，通过 `export LD_LIBRARY_PATH=/path/to/lib` 设置，该设置优先级大于 `RUNPATH`。
3. `RUNPATH`, 如果设置了 `RUNPATH` 则会直接覆盖 `RPATH`。
4. `/lib`、`/usr/lib`、`/usr/local/lib` 等系统默认路径。
5. `/etc/ld.so.conf` 这个指定路径。

对于 `RPATH` 和 `RUNPATH` ，这两个则是编译时嵌入进去的。

> 为什么既有 `RPATH` ，又后续加入 `RUNPATH` ？一个原因是：`RPATH` 没法被覆盖，但是每个机子的情况又不一样，可能需要手动指定 `LD_LIBRARY_PATH` 才可以，因此 `RUNPATH` 提出来了。
