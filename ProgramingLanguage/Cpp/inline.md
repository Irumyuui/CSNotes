# inline

## 内联函数

对于 `inline` 语义，本来的语义是内联函数，也就是将一个函数在调用处展开。不过对于现代编译器来说，这个功能仅是一个标识，不一定会内联。

如果一个函数真的确定需要被内联，那么应该是使用以下的方式。

```c++
__attribute__((always_inline))
int Add(int a, int b) {
    return a + b;
}
```

这样的函数声明会告诉编译器，无论什么情况下都要内联这个函数。

对于现在的 `inline` ，更重要的功能是：允许多重定义。这个多重定义不是说在同一个文件中可以有多个同名函数，而是说在不同文件中可以有同名函数（还有变量），也就是对于多个编译单元，可以存在多个定义，此时这个定义就变成了弱定义。

> 更多的，允许多重定义的一个原因是这个特性是来自于之前内联函数的副作用，也就是一个函数可以在多个位置出现，那么如果是强定义则肯定会出现重复定义的问题。

```c++
// Foo.hpp
inline int Add(int a, int b) {
    return a + b;
}

// Bar.hpp
inline int Add(int a, int b) {
    return a * b;
}
```

这样编译后是可以的，但是标准已经确定，如果出现多重定义，一般的实现就是取遇到的第一个定义。

## 内联变量

内联对象又是一个什么东西？

刚刚说过，`inline` 的语义已经变成了将一个符号变为弱定义的东西，那么对于不同的变量也是如此。

```c++
inline int x = 10;
```

得益于此，对于类内的 `static` 变量，那么可以直接定义了。

```c++
struct Foo {
    static int a = 10;         // Error, 需要在类外才能定义
    inline static int a = 10;  // Ok.
};
``
