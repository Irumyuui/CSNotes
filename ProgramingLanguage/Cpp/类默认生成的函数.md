# 类默认生成的函数

众所周知，`c++` 中类会默认生成一些函数。

```c++
class Foo {
public:
    // 11 之前的
    Dog();                      // 默认构造函数
    Dog(const Dog&);            // 拷贝构造函数
    ~Dog();                     // 析构函数
    Dog& operator=(const Dog&); // 拷贝赋值运算符

    // 11 之后的
    Dog(Dog&&);                 // 移动构造函数
    Dog& operator=(Dog&&);      // 移动赋值运算符
};
```

这些函数不是编译器会自动给你的代码生成的，有一定的条件。

## 默认构造函数

没其他的构造函数时，才会默认生成。

```c++
struct Foo {
    Foo(int);           // 阻止了默认构造函数的生成
    Foo() = default;    // 显式声明默认构造函数
};
```

## 拷贝构造 / 拷贝赋值运算符

如果没有定义移动构造函数和移动赋值函数时，才会默认生成拷贝构造函数和拷贝赋值运算符。

很好说，因为如果这个类定义了自己的移动构造，那么是不是其中的资源**无法被拷贝**呢？编译器无法判断。

## 析构函数

析构函数是一定会有的。

## 移动构造 / 移动赋值运算符

如果没有显示定义拷贝构造函数、拷贝赋值运算符、析构函数，还有与之对应的构造或者赋值函数（也就是如果是移动构造，那么必须没有自定义的移动赋值）时，编译器会自动生成移动构造函数和移动赋值运算符。

如果一旦定义拷贝构造，那么其中的资源到底是不是移动比较好，编译器不能判断，很好理解。

如果定义了析构函数，那么意味着类中的资源需要被手动管理（即使这个管理来自 RAII 的保证），所以编译器不会自动生成移动构造函数和移动赋值运算符，你需要自己去实现。

至于为什么实现了其中一个，另外一个不会自己生成，一个原因是自己实现了那么编译器不知道其中你要怎么实现移动，典型例子是：移动构造函数不需要考虑自己，而移动赋值运算符需要考虑是不是资源移动给了自己。

## Copy and Swap

两个赋值函数其实可以合并作为一个的。

```c++
struct Foo {
    // Foo() = default;
    // Foo(const Foo&) = default;
    // Foo(Foo&&) = default;

    Foo& operator=(Foo);  // 这里既能接受移动，也能接受拷贝，都会先派发到两个构造函数去先构造  
};
```
